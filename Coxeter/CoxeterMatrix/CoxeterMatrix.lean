import Coxeter.OrderTwoGen
import Coxeter.CoxeterMatrix.TestGroup
import Mathlib.GroupTheory.Coxeter.Matrix
import Mathlib.GroupTheory.Coxeter.Length

/-!
# Coxeter Matrices

This file contains basic definitions and properties of Coxeter matrices.
Then we have a group `G` generated by a set `S` of order 2 elements, proving
a `OrderTwoGen` instance.

# Main Definitions
1. For any `CoxeterMatrix m`, we define a subset `R = toRelationSet m` of relations in the free group `F` over `α`.
2. We define the quptient group `G = F/ < R >`.
3. We denote the image of `α` in `G` by `S`. The set `S` is called the set of simple reflections of `G`.
4. We define a group homomorphism `epsilon` from `G` to the group `μ₂`.
This result relies on the file `TextGroup.lean` for the construction of `μ₂`.
5. We show elements in `S` are all of order 2. So `G` is a group generated by order 2 elements.
-/

open BigOperators
open Classical

section

variable {B W : Type*} [Group W] {M : CoxeterMatrix B} (cs: CoxeterSystem M W)

local prefix:max "s" => cs.simple
local prefix:max "ℓ" => cs.length
local prefix:max "ris" => cs.rightInvSeq
local prefix:max "π" => cs.wordProd

namespace CoxeterMatrix



lemma diagonal_one {a : B} : M a a = 1 := diagonal M a

lemma off_diagonal_ne_one {a b : B} : a ≠ b → M a b ≠ 1 := off_diagonal M a b

lemma one_iff {a b : B}: M a b = 1 ↔ a = b := by
  constructor
  · convert (off_diagonal M a b).mt <;>
    tauto
  · intro h
    simp only [h, diagonal]

local notation "F" => FreeGroup B

lemma lift.of {A : Type _} [Group A] {f : B → A} (h : IsLiftable M f) (w : B) : CoxeterSystem.lift cs h (s w) = f w := by
  sorry

open TestGroup

/- We define (and prove) a group homomorphism from `W` to `μ₂`
by mapping each simple reflection to the generator of `μ₂`.
-/

-- @[simp]
def epsilon : W →* μ₂ := CoxeterSystem.lift cs (f := (fun _ => μ₂.gen)) (by intro u v; ext; simp)

lemma epsilon_of (u : B) : epsilon cs (s u) = μ₂.gen := by
  simp only [epsilon, lift.of cs]

@[simp]
lemma of_relation (u v : B) : ((s u) * (s v)) ^ (M u v) = 1 := by
  sorry
  /-set M := toRelationSet m
  set k := ((FreeGroup.of s) * (FreeGroup.of t))^(m s t)
  have kM : (k ∈ M) := by exact Exists.intro (s, t) rfl
  have MN : (M ⊆ N) := by exact Subgroup.subset_normalClosure
  have kN : (k ∈ N) := by exact MN kM
  rw [of, of]
  have : (((QuotientGroup.mk' N) (FreeGroup.of s) * (QuotientGroup.mk' N) (FreeGroup.of t)) ^ (m s t)
    = (QuotientGroup.mk' N) ((FreeGroup.of (s) * FreeGroup.of (t)) ^ (m s t))) := by rfl
  rw [this]
  apply (QuotientGroup.eq_one_iff k).2
  exact kN-/

lemma of_square_eq_one {u : B} : (s u) * (s u) = 1 := by
  sorry
  /- have : m s s = 1 := diagonal_one m
  rw [← pow_one ((of m s) * (of m s)), ←this]
  apply of_relation m s s -/

-- @[gprod_simps]
lemma of_square_eq_one_right (u : B) (g : W) : g * (s u) * (s u) = g := by
  sorry /- rw [mul_assoc, of_square_eq_one'' m s, mul_one] -/

lemma of_inv_eq_of {x : B} : (s x)⁻¹ = s x :=
  sorry /- inv_eq_of_mul_eq_one_left (@of_square_eq_one α m hm x) -/

lemma SimpleRefl_eq_iff_eq (u : B) (g : W) : (s u) = g ↔ (s u)= (s u) * g * (s u) := by
  sorry
  /- convert Group.eq_iff_eq_conjugate (s : G) g
  apply mul_eq_one_iff_eq_inv.mp (of_square_eq_one' m s.2)
 -/

/- Lemma: The group `G` is generated by the set S.
-/
lemma toGroup_expression : ∀ (x : W), ∃ L : List B, x = π L := by
  sorry
  /- intro x
  apply (Submonoid.mem_monoid_closure_iff_prod S x).1
  have h₀ : S = S ∪ S⁻¹ := by rw [← SimpleRefl_closed_under_inverse, Set.union_self]
  have h₁ : Subgroup.closure S = ⊤ := by
    rw [SimpleRefl, Set.range]
    simp only [of, toGroup, PresentedGroup]
    have : Subgroup.closure {x | ∃ y, (QuotientGroup.mk' N) (FreeGroup.of y) = x}
      = Subgroup.closure (Set.range (PresentedGroup.of)) := rfl
    rw [this, PresentedGroup.closure_range_of]
  rw [h₀, ← Subgroup.closure_toSubmonoid, Subgroup.mem_toSubmonoid, h₁]
  trivial -/

/--
Lemma: Let `s ∈ S` be a generator of `G`, then `s` is non-trivial.
-/
lemma generator_ne_one (s : α) : of m s ≠ 1 := by
  intro h
  have h1 : epsilon m (of m s) = 1 := by rw [h]; simp
  have h2 : epsilon m (of m s) = μ₂.gen := by rw [epsilon_of]
  rw [h2] at h1; exact μ₂.gen_ne_one h1

/--
Lemma: Let `s ∈ S` be a generator of `G`, then `s` is non-trivial.
-/
lemma generator_ne_one' {x : G} : x ∈ S → x ≠ 1 := by
  rintro ⟨s, hs⟩
  rw [← hs]
  exact generator_ne_one m s

/--
Lemma: Let `s ∈ S` be a generator of `G`, then `s^2 = 1` and `s ≠ 1`.
-/
lemma order_two : ∀ (x : G), x ∈ S → x * x = (1 : G) ∧ x ≠ 1 := by
  rintro x ⟨s, hs⟩
  rw [← hs]
  exact ⟨of_square_eq_one m, generator_ne_one m s⟩

/--
Instance: The group `G` with the generating set `S` is a group generators by order 2 elements.
-/
instance ofOrderTwoGen : OrderTwoGen (SimpleRefl m) where
  order_two := order_two m
  expression := toGroup_expression m

end CoxeterMatrix
